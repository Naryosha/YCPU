YCPU Specification
Version 0.6A RC3

### Table of Contents ##########################################################

        1.      Introduction
        1.A.        Public Domain Dedication
        2.      Hardware Information
        2.A.        Registers
        2.B.        Supervisor/User Modes
        2.C.        Hardware Devices
        2.D.        Interrupts
        2.E.        Addressing Modes
        2.F.        Memory Management
        2.G.        Boot Sequence
        2.H.        The Real Time Clock
        2.I.        Switching Context
        3.      Instructions
        3.A.        Bit Patterns
        3.B.        ALU Instructions
        3.C.        Bit Shifting Instructions
        3.D.        Bit Testing Instructions
        3.E.        Branch Instructions
        3.F.        Immediate Instructions
        3.G.        Interrupt Instructions
        3.H.        Jump & Call Instructions
        3.I.        Stack Instructions
        3.J.        Processor Function Instructions
        4.      History


### 1. Introduction ############################################################

The YCPU Specification describes a processor with a comprehensive instruction
set and features that make a processor built to the specification powerful yet
easy to wrote software for. The specification is released to the public domain,
and can be used in derivative works without permission.


=== 1.A. Public Domain Dedication ==============================================

This document is dedicated to the public domain under the terms of the Creative
Commons Zero (CC0) waiver. All rights have been waived with regard to
copyright law, including all related and neighbouring rights, to the extent
allowed by law.

You can copy, modify, and distribute this document, and use it to create
derivative works, even for commercial purposes, all without asking permission.

More information about CC0 waiver is available online at: 
http://creativecommons.org/about/cc0


### 2. Hardware Information ####################################################

The YCPU is a 16-bit processor. The processor includes features intended to ease
the development of software, including a comprehensive instruction set, eight
general purpose registers that can be used as data or address registers and are,
with one small exception, completely orthogonal; support for 32-bit floating
point operations, a MMU that allows read/write/execute protection and bank
switching of 4 16 kilobyte banks within the 16-bit logical address space, a real
time clock, a hardware bus that supports up to 255 devices, and Supervisor/User
modes with different privileges and stack pointers.


--- 2.1. MEMORY MODEL ----------------------------------------------------------

Internally, all registers and cache words are 16-bit, and all logical addresses
are likewise 16-bit. Thus instructions can only address 64 kilobytes of memory
at any time. All multi-word values are stored in little-endian format.

--- 2.2. INSTRUCTION WIDTH: 16-BIT ---------------------------------------------

For most instructions, the only addressable unit of memory is a 16-bit word.
8-bit operations are supported for any instruction which uses the "ALU" bit
pattern: Load, Store, Add, Subtract, Multiply, Divide, Bitwise And, Bitwise Or,
Bitwise Not, Bitwise Exclusive Or, Compare, and Negate. When executing 8-bit
operations in registers, the upper 8-bits of memory are cleared and ignored.
When executing an 8-bit STOre operation, the processor will store only one byte,
and the second byte in the 16-bit word in memory will not be affected. When
executing an 8-bit load operation, the processor will load only the lower byte
at the address, and the upper 8-bits of the destination register will be
cleared.

For all other instructions there is no support for 8-bit maths. All other
instructions operate on 16-bit vales at all times (with the exception of MUL/MLI
which has a 32-bit result with the upper 16 bits of the result stored in R0).


--- 2.3. MEMORY ACCESS ---------------------------------------------------------

For 16-bit memory access, access is quickest when aligned to 2-byte boundaries,
and slower when accesses are unaligned. Thus, memory accesses from $0000 and
$0002 are faster than $0001 and $0003. For unaligned memory accesses, the YCPU
loads the two bytes for a 16-bit word in separate memory access cycles.

For 8-bit access, the YCPU loads only one 8-bit value. A single 8-bit load is
as fast as a 16-bit load.


--- 2.4. ON-CHIP HARDWARE ------------------------------------------------------

All models of the YCPU are guaranteed to have 4 x 16kb of internal RAM on board.
The YCPU will also have a variable amount of ROM on chip, depending on the
model of the YCPU and the needs of the processor distributor. Generally, this
ROM will consist of a basic input/output system that will bootstrap the system
and prepare it to load other software. The YCPU can determine how much RAM/ROM
is available by querying 'Hardware Device 0' on the Hardware Bus.


=== 2.A. Registers =============================================================

    R0-R7: General Purpose Registers (also commonly named A,B,C,I,J,X,Y, and Z)
    FL: Flags register
    IA: Interrupt Address
    II: IRQ Index
    PC: Program Counter
    PS: Processor Status
    P2: Processor Bank Fault Address
    SP: Stack Pointer. The YCPU has separate stack pointers for user mode (USP)
        and supervisor mode (SSP). See 2.A.2.


--- 2.A.1. GENERAL PURPOSE REGISTERS -------------------------------------------

The processor has 8 general purpose 16-bit registers, which can be referenced as
R0~R7 or by alternate names A, B, C, I, J, X, Y, and Z. These registers are
used as both data and address registers, are completely interchangeable
(orthogonal), and are directly referenced and modified by most instructions.

There is one exception to general purpose register interchangeability: R0 is the
destination of the high 16-bits of the result of MUL (multiply) and MLI (signed
multiply) operations, which have 32-bit results. If R0 is also the src/dest
register, then the high 16-bits are lost, and R0 will contain the low 16-bits
after the instruction completes.


--- 2.A.2. PROCESSOR STATUS REGISTERS ------------------------------------------

The processor has eight processor status 16-bit registers. Unlike the general
purpose registers, these are not accessible by most instructions. The eight
processor status registers are FL, IA, II, PC, PS, P2, SSP, and USP.

    FL: The FLag register. This register contains flags that are set by ALU
        operations.
        The flags are as follows:
        FEDC BA98 7654 3210
        NZCV .... .... ....
            [N]egative, [Z]ero, [C]arry, o[V]erflow
         
    IA: The Interrupt Address. This is the base address of the interrupt address
        table, comprised of 16 x 16-bit words. IA is initialized to $0000.
        
    II: The IRQ Index. This is the bus index of the device that raised the last
        hardware interrupt.
    
    PC: The Program Counter. Contains the address of the next instruction to
        execute. It is incremented by 1 after executing an opcode that does
        not reference a next word, or 2 after executing an opcode that does
        reference a next word value.
    
    PS: The Processor Status. Setting or clearing bits in this register enables
        and disables processor features. The bits are as follows:
        FEDC BA98 7654 3210
        SMI. QUW. .... ....
            [S] -   [S]upervisor Mode enabled
            [M] -   [M]emory Management hardware enabled
            [I] -   Hardware [I]nterrupts enabled.
            [Q] -   Interrupt Re[Q]uest in process, blocks hardware interrupts.
            [U] -   Bank Fault, User Attempt to Access Supervisor-Only Memory
            [W] -   Bank Fault, Attempt to Write to Read-Only Memory
            
    P2: Processor Status 2. Set during bank fault interrupt.
    
    SP: The Stack Pointer is the address of the first full stack space. It is
        decremented before a stack value is pushed onto the stack, and is
        incremented after a stack value is popped from the stack. Thus the
        grows downward from its initial address, and should be initialized to
        an address at (Stack Bottom + 1). Example: If SP is set to $0000, the
        first pushed value will be at $ffff, and the first pulled value will
        be read from $0000.
        
        The processor has two different stack pointers - the Supervisor Stack
        Pointer, or SSP, is used while the processor is in Supervisor mode, and
        the User Stack Pointer, or USP, is used while the processor is not in
        Supervisor mode. Thus, software running in User mode can ruin the
        stack, and the Supervisor mode stack will remain untouched. 

        
=== 2.B. Supervisor/User Modes =================================================
Supervisor mode is enabled when the S bit in the PS register is set, which is
true on processor boot and whenever an interrupt is called. When the S status
bit is clear, the processor is in User mode.

In Supervisor mode, the processor:
    * Can execute privileged opcodes.
    * Can access Supervisor-only memory banks.
    * Raises a 'Bank fault' interrupt on attempting to write to read-only
      memory.
    * Can set and clear all bits in the process status registers.
    * Has access to all Special Registers.
    * Can directly access the hardware bus.
    * Uses the Supervisor Stack Pointer (SSP).

In User mode, the processor:
    * Raises an 'Unprivileged Opcode' interrupt on executing privileged opcodes.
    * Raises a 'Bank fault' interrupt on attempting to read or write
      supervisor-only memory, or write to read-only memory.
    * Cannot access any special registers.
    * Cannot directly access the hardware bus.
    * Uses the User Stack Pointer (USP).


=== 2.C. Hardware Devices ======================================================
All additional Devices connect to the processor through a modular Hardware Bus.
This Hardware Bus can host up to 15 Devices. The processor can directly address
memory banks exposed by the Devices, and can also directly communicate with a
Device by executing a Hardware Query instruction. Devices can request the
processor's attention by raising an interrupt.

Possible hardware Devices can include input (keyboard, mouse, touch), storage
(disk, hard drive), networking, RAM, ROM, and interfaces for other hardware
Devices not directly connected to the Hardware Bus.

Device Index 0 on the Hardware Bus refers to the YCPU itself. Software can
retrieve information about the YCPU by using the Hardware Query instruction to
query the Device at Index 0.

Note that Hardware Devices have full access to the YCPU's active memory, but
only one device or the processor can access memory at once. Thus, while a
device is reading or writing memory, the processor is stalled.


--- 2.C.1. INTERACTING WITH HARDWARE --------------------------------------------

Software interacts with hardware using the HWQ (HardWare Query) instruction.
This instruction accepts one operand, a 8-bit 'operation index'. Calling HWQ
operation $00 will query the Bus for the number of devices connected, and
the YCPU will save this value in R0. The YCPU can also determine what device is
present in each of the 255 Bus Slots by calling HWQ operation $01 with the index
of the Bus Slot to check in R0. If no device is present, R0 will be set to
"ERR_NO_DEVICE" ($0000). If a device is present, the registers of the YCPU will
be set as follows:

        R0: Device Type
        R1: Manufacturer ID
        R2: Device ID
        R3: Device Flags
        
Software can send messages to a Bus Device by calling HWQ operation $02. This
will send a two-word message, consisting of the words in R1 and R2, to the
Hardware Device in Bus Slot R0. If there is no hardware device in this Bus Slot,
there will be no effect. If there is an active Hardware Device in this Bus Slot,
one of several results will occur:

    If the device can instantly respond to the message, it will acknowledge the
    message by setting R0 to "MSG_ACK" ($0001). R1 and R2 may also be used as
    return parameters, if required by the device.
    
    If the device requires time to respond to the message, it will acknowledge
    the message by setting R0 to "MSG_WAIT" ($0002). When the device is ready
    to respond to the message, it will raise a Hardware Interrupt.
    
    If the device requires access to main memory, the processor will be halted
    while the device reads/writes to memory. Generally, the memory read to will
    be based on the contents of R1 and R2. Software can send more than two
    parameters to a device by using R1 or R2 as a pointer to memory. When the
    device has completed its operation, it will set R0 to "MSG_ACK" ($0001).
    
    If the device encounters an error while responding to the message, it will
    acknowledge the message by setting R0 to "MSG_ERROR" ($FFFF). R1 and R2
    will remain unchanged.


=== 2.D. Interrupts ============================================================
An interrupt is a signal which indicates that an event requires immediate
attention. Interrupts can be triggered by a hardware device, by software using
the SWI opcode, or when the processor encounters an error state.


--- 2.D.1. HARDWARE INTERRUPTS -------------------------------------------------

A device on the CPU's hardware bus may request the CPU's attention by asserting
an interrupt request (IRQ). While the Q status bit is clear and the I status bit
is set, the processor checks for IRQs before executing every opcode. If a
hardware device is asserting an IRQ when the processor checks, the processor
will load the bus index of the first device on thus bus which is asserting an
IRQ into the II register, and then raise the 'hardware interrupt' interrupt.

Note that devices in lower index slots in the hardware bus always have
priority over devices in higher index slots.


--- 2.D.2. SOFTWARE INTERRUPTS -------------------------------------------------

An interrupt may also be triggered by the SWI opcode. In this case, the
processor will raise the 'software interrupt' interrupt vector, and the code
at that interrupt must determine what function has been requested, based on the
contents of the registers.

Unlike hardware interrupts, software interrupts will be acknowledged
regardless of the status of the Q status bit

The I status bit only applies to hardware interrupts, and thus software
interrupts will be acknowledged by the CPU if the I status bit is clear. 
    
--- 2.D.3. OTHER INTERRUPTS ----------------------------------------------------

The processor can also raise interrupts on its own in response to error
states. These interrupts are named and described in the Interrupt Vector Table,
below.

    
--- 2.D.4. THE INTERRUPT SEQUENCE ----------------------------------------------

When an interrupt is raised, the processor halts the current executing process.
It then executes the following sequence:
    1.  Save the state of PS to a temporary register.
    2.  Set the S status bit. The processor is now in Supervisor mode.
    3.  If this is a hardware interrupt, the Q status bit will be set. This
        blocks other hardware interrupts from occurring while the current
        interrupt is being processed. If this is a BankFault, P2 is set to the
        address of the memory address that raised the BankFault.
    4.  Push the saved PS to the Stack.
    5.  Push PC* to the Stack.
    6.  Set PC to Mem[II + (InterruptIndex * 2)].
    7.  Execution continues.  

* For the interrupts which are raised by an error condition, the PC is rewound
  to the instruction that *caused* the the interrupt. Interrupts raised by error
  conditions are: DivideByZero ($02), FPUError ($03), StackFault ($04),
  BankFault ($05), UnprivOpcode ($06), and UndefOpcode ($07). For all other
  interrupts, the PC is unchanged, pointing to the address following the
  instruction the processor was executing immediately prior to the interrupt.


--- 2.D.5. RETURNING FROM AN INTERRUPT -----------------------------------------

When an interrupt handler ends, it should call RTI, which restores the values of
PS and PC from the stack. If an interrupt handler modifies a register or changes
the MMU cache, it should save the state of the registers and/or cache before
doing so, and restore the same before returning from the interrupt handler.

Note that on RTI, PS bits are restored to the value they had prior to the
interrupt.

The RTI instruction follows this sequence:
    1.  Pop PC, PS from the Stack.
        PC bits Q, U, W, and E are cleared.
    2.  Execution Continues.
    

--- 2.D.6. THE INTERRUPT VECTOR TABLE ------------------------------------------

There are 16 interrupts in the Interrupt Vector Table. The software interrupt
is raised by the instruction SWI, and the Hardware Interrupt is raised by a 
hardware which asserts an interrupt request. All other interrupts are raised
by the processor itself on specified error states. The 16 interrupts are:

Idx Name            Description
$0  Reset           Raised when the processor's RESET line is pulled high.
                    The processor will follow the boot sequence (See 2.G.).
$1  Clock           Raised when the processor's Real Time Clock ticks. The tick
                    rate can be set by writing to the RTC register.
$2  DivideByZero    Raised when the processor executes a division or modulus
                    opcode where the operand containing the denominator is zero.
$3  RESERVED        Not currently used, never raised.
$4  StackFault      Raised when the processor executes a Pull opcode with SP 
                    equal to the high-value limit of the Stack, or the processor 
                    executes a Push opcode with SP equal to the low-value limit 
                    of the Stack.
                    Note that limits to the Stack are not yet included in this
                    Specification.
$5  BankFault       Raised when the processor attempts to read from or write to 
                    an address within a Bank which has been protected from these
                    operations. The UW bits in the PS register will describe the
                    error, and the P2 register will contain the memory address
                    that the processor attempted to access.
$6  UnprivOpcode    Raised when the processor attempts to execute a privileged
                    opcode while in User mode.
$7  UndefOpcode     Raised when the processor attempts to execute an UNDEFINED
                    opcode.
$8  RESERVED        Not currently used, never raised.
$9  RESERVED        Not currently used, never raised.
$A  RESERVED        Not currently used, never raised.
$B  RESERVED        Not currently used, never raised.
$C  HWI             A device on the Hardware Bus has requested an interrupt.
                    II = bus index of the requesting device.
$D  BusRefresh      Raised when the hardware on the bus has changed. Note that
                    all hardware ids at this point may be invalidated.
$E  DebugQuery      Raised when the processor's DEBUG line is pulled high.
$F  SWI             Raised by the SWI opcode.


--- 2.D.6. BANK FAULTS ---------------------------------------------------------

When a bank fault is raised, the processor status bits U, W, and E will describe
the operation that caused the bank fault:
        U W     Bank Fault Type
        0 0     Attempted access to bank that is not loaded. (P bit set)
        0 1     Attempted supervisor write of write-protected memory.
        1 0     Attempted user read of supervisor-only memory.
        1 1     Attempted user write to supervisor-only memory.
        
Note that writes to ROM banks will fail silently unless the MMU is enabled and
the write-protect bit is set, which will generate a bank fault.


=== 2.E. Addressing Modes ======================================================
Many instructions are register-only: they can take only data loaded in registers
as their source. But all Load, Store, ALU, and Jump instructions can access
memory using these nine addressing modes:

Addressing Mode     Syntax      Value is...
Immediate           $1234       Value of Next Word
Absolute            [$1234]     Mem[Next Word]
Register            Rx          Value of Register
Indirect            [Rx]        Mem[R]
Indirect Offset     [Rx,$1234]  Mem[R + Next Word]
Absolute Offset     [$1234,Rx]  Mem[R + Next Word]  // Same as Indirect Offset
Stack Offset        S[$0-$7]    Stack[Offset]       // Offset limited to 0-7
Indirect Post-inc   [Rx+]       Mem[R], R is post-incremented. (See 2.E.2.)
Indirect Pre-dec    [-Rx]       Mem[R], R is pre-decremented. (See 2.E.2.)
Indirect Indexed    [Rx,Rx]     Mem[R+R]

--- 2.E.1. BIT WIDTH OF INSTRCTIONS --------------------------------------------

ALU instructions are by default 16 bits wide. Thus, all LOD instructions take
16 bits from memory, and ADD instructions operate on all 16 bits of memory.
There is an alternate 8-bit mode for ALU instructions (ADD, STO, LOD, etc.):

    LOD.8   [$8000]
    STO.8   [$8000]
    
These alternate instructions will operate on only the low 8 8-bits of a 
register. 8-bit LOD instructions will load a single byte into memory from a
register. The high 8 bits of the destination register will be cleared. 8-bit STO
instructions will store the low 8 bits from the source register. If the target
of the instruction is memory, only a single byte is stored in memory. If the
target is another register, the lower 8 bits of memory are stored, and the high
8 bits of the destination register are cleared.

--- 2.E.2. POST-INCREMENT AND PRE-DECREMENT VALUES -----------------------------

When using post-increment and pre-decrement, the value of the register is
changed the value of the register is changed by the byte-size of the data
operated on by the instruction. Thus:

    ADD.8   R0, [R1+]           ; will post-increment R1 by '1'.
    LOD.8   R0, [R1+]           ; will post-increment R1 by '1'.
    ADD.8   R0  [R1+]           ; will post-increment R1 by '2'.
    LOD.16  R0, [R1+]           ; will post-increment R1 by '2'.


=== 2.F. Memory Management =====================================================
Because the processor has a 16-bit logical address space, it can only address
$10000 bytes of linear address space at a time. This limited address space is
augmented by the processor's integrated memory management unit (MMU) which,
when enabled, implements bankable memory and thus a limited form of virtual
address translation.


--- 2.F.1. THE MMU CACHE -------------------------------------------------------

The MMU has 8 16-bit words of internal cache. Each pair of words describes
the physical address that is mapped to a single MMU bank. 4 of these 16-bit
words describe the configuration of the 4 banks of memory in supervisor mode,
and the other 4 describe the configuration of the 4 banks of memory in user
mode. 

Word $00___________
FEDC BA98 7654 3210
SWPA DDDD bbbb bbbb
    
    S - Supervisor only flag:
        0:  User mode and Supervisor mode may access this bank.
        1:  Supervisor only. User mode accesses to this bank will fail and
            cause a bank fault.
    W - Write protection flag:
        0:  Write operations to this bank will succeed.
        1:  Write-protected. Writing to this bank will fail and cause a bank
            fault.
    P - Not present flag:
        If this bit is set, any access to this bank will raise a bank fault.
    A - Accessed flag:
        This bit is set every time this bank is written to.
    D - These bits determine the device that the bank of memory if mapped from.
    b - These bits determine the bank of memory that is mapped to this bank of
        virtual address space (note that the YCPU's ROM is indicated by setting
        the high 'b' bit for device 0).

--- 2.F.2. ADDRESS SPACE WHEN THE MMU IS DISABLED ------------------------------

When the 'M' status bit is in PC clear, the MMU is disabled, and the processor's
address space is mapped as follows:
    $0000-$0FFF : Internal ROM Bank $00
    $4000-$7FFF : Internal RAM Bank $01
    $8000-$BFFF : Internal RAM Bank $02
    $C000-$FFFF : Internal RAM Bank $03

The equivalent MMU register values would be as follows:

    $00 : $0080                 ; bank hi bit for device zero selects ROM banks.
    $01 : $0001
    $02 : $0002
    $03 : $0003

--- 2.F.3. ADDRESS SPACE WHEN THE MMU IS ENABLED -------------------------------

While the 'M' status bit in PC is set, the MMU is enabled, and will translate
memory references to physical addresses. It does so by dividing the processor's
virtual address space into 4 banks of 16 kilobytes each. The high two bits of
the virtual address select the bank of memory that is accessed, and the low
fourteen bits of the virtual address select a byte of memory within that bank.

Note that there are different MMU caches for both user and supervisor mode. The
supervisor can set both caches, while the user mode can set neither. 

        
--- 2.F.4. ADDRESS TRANSLATION -------------------------------------------------

The MMU has access to 26 bits of physical address space. A physical address is:

        FEDC BA98 7654 3210     FEDC BA98 7654 3210
        .... ..DD DDbb bbbb     bbaa aaaa aaaa aaaa

'a' is the 14-bit address of a byte within that bank.
'b' is the 8-bit index of the device bank mapped to that 16kb bank.
'D' is the 4-bit hardware bus index that the bank is taken from.

The 8 'b' bits reference a bank of RAM or ROM from a device on the hardware
bus. The 4 'D' bits are a 8-bit hardware bus index. Because no hardware device
can have more than 2^8 = 256 banks, each bank can host no more than 4
megabytes of memory, and the MMU as a whole can address no more than
2^26 bytes = 64 megabytes of memory.

Note that when selecting memory banks from processor space (device index 0), the
high bit of the bank selection index (bit 7 of bank/device select) indicates a
ROM bank. When this is clear, a RAM bank is selected.


--- 2.F.5. FAR JUMPS -----------------------------------------------------------

The YCPU is internally 16-bit, and can address only 16-bits of logical address
space. When the MMU is active, this memory is comprised of four 'banks', each of
16k bytes. Which banks of memory are placed in memory is determined by the
MMU. As noted in 2.F.3., supra, software may manipulate the MMU cache using the
MML/MMR/MMW/MMS instructions to load and save values from the MMU cache; this
will change which banks are loaded within the logical address space.

Running software may also replace a bank in memory using a 'far jump'. Where a
normal jump instruction sets only the PC register, a far jump will also switch a
new bank of memory into the address space containing the new PC value. The
addressing mode of the instruction will indicate where the processor will find
the word describing which Device and which Bank will occupy the address space
containing the new address of the PC.

An example of a far jump with immediate addressing will help illustrate how this
works. Note that 'immediate addressing' indicates that the processor uses the
next word following the current instruction as the new value of the new PC. With
a far jump, the processor will use a second word immediately following the first
operand as the second operand, as follows:

    JMP.F $FF06:$010E ; far jump to address $F006 in bank $0E in device $01.
    
    The processor sees this instruction as 3 words (6 bytes) containing five
    sets of data:
    
    $00________________ $01________________ $02________________
    OOOO OOOO OOOO OOOO bbaa aaaa aaaa aaaa .... DDDD BBBB BBBB
    
    O = 16-bit opcode, indicating a 'far jump immediate' instruction.
    b = the bank which will contain the new PC value.
    a = the address of the PC within that bank.
    D = the index of the Device which will provide the bank.
    B = the index of the Bank within the Device.
    
The two 'b' bits indicate the MMU bank which the new device bank will be
'switched' into. The top two bits of '$F006' are '11', or '3'. Thus, the bank
will switch bank $0E from device $01 into the fourth MMU address space (MMU
banks are zero indexed) which extends from $C000 to $FFFF.
    
Following the operation, the PC will be set to $F006, and the fourth MMU bank
will contain Bank index $0E from Device $01.

Note 1: far jumps will clear all flags in the upper word for the MMU cache entry
        containing that bank.
Note 2: far jumps are only accessible from Supervisor mode. If the processor
        attempts to execute a far jump while in user mode, the processor will
        raise an 'UnprivOpcode' exception. Thus, these instructions could still
        be used while in User mode; the processor interrupt would have to 'trap'
        these instructions. Alternatively, software running in User mode could
        use a SWI instruction for the same purpose.
Note 3: when the MMU is disabled, a far jump will still set the lower word for 
        the MMU cache entry for the specified bank, but (because the MMU is
        disabled) the address space will remain unchanged.

--- 2.F.7. UNLOADED MEMORY -----------------------------------------------------

Any memory accesses to addresses which are not connected to real memory will
result in reads with all bits set. Thus, a 16-bit read of address $C000, when
the fourth MMU bank is set to memory that does not exist, will result in a 
value of $FFFF.
        
=== 2.G. Boot Sequence =========================================================
At initial power on, the state of all memory, registers, and cache is unknown.
The processor raises the RESET interrupt at power on, which puts the processor
in the following known state:

    RTC Tick <- Disabled            ; RTC will not raise interrupts.
    PS <- $8000                     ; Supervisor mode is enabled, all other
                                    ; processor features disabled.
    IA <- $0000                     ; Interrupt vector table begins at $0000
    PC <- [InterruptTable[$0]]      ; Execute 'RESET' interrupt code.

Because Memory Banking is disabled, the processor's virtual address space is set
up as follows: $0000-$3FFF is processor ROM bank 0, and $4000-$FFFF is processor
RAM. This is discussed in further detail in 2.F.1., supra.
    

=== 2.H. The Real Time Clock ===================================================
The processor contains an integrated Real Time Clock (RTC). The RTC maintains
and updates its internal time data indefinitely, even when the processor is
powered down. The processor can query the RTC for the current time.

--- 2.H.1. RTC Date/Time data --------------------------------------------------

The clock provides time data with the following precision:
    Year:    8 bits (0-255)
    Month:   4 bits (0-11)
    Day:     5 bits (0-31)
    Hour:    5 bits (0-23)
    Minute:  6 bits (0-59)
    Second:  6 bits (0-59)
    M.Sec.: 12 bits (0-1000)
    
This data is saved to R0-R3 upon calling HWQ $80, in this format:

                                                    FEDC BA98 7654 3210
                    R0: 8 bits Year, 4 bits Month   .YYY YYYY .... MMMM
                    R1: 5 bits Day, 5 bits Hour     ...D DDDD ...h hhhh
                    R2: 6 bits Min, 6 bits Second   ..mm mmmm ..ss ssss
                    R3: 16 bits Tick                tttt tttt tttt tttt
                    
The original epoch for this device is 1 January 1900 at Midnight. This device
will 'roll over' at 1 Janaury 2156. YpsilonTech offers technical assistance at
exceptionally reasonable rates to companies who wish their software to
gracefully handle this roll-over. YpsilonTech accepts no responsibility for
software written without this assistance, and thus experience a "Y2156" bug.

--- 2.H.2. The CLOCK interrupt -------------------------------------------------

The RTC also provides a CLOCK interrupt, which can be enabled, disabled, and the
frequency of which can be specified. When the RTC interrupt is enabled, the RTC
will raise the CLOCK interrupt at an interval which is specified by the
processor. The RESET interrupt disables the RTC.

The processor can set the desired interrupt interval with HWQ $81, with a value
indicating the desired interrupt frequency in R0. If R0 is $0000, the interrupt
will be disabled. Otherwise,  the CLOCK interrupt will be raised at a frequency
of R0 hz, capped to a maximum of cpu frequency divided by 1024.

After this operation, R0 will be set to the actual CLOCK interrupt frequency.
Software can thus request a high CLOCK rate, and be informed of the actual CLOCK
rate by examining R0.


=== 2.I. Switching Context =====================================================
The RTI instruction can also be used to switch the processor into user mode,
even switiching contexts entirely when doing so. 

--- 2.I.1. Switching from Supervisor Context to User Context -------------------

When the MMU is enabled, the layout of memory is different in Supervisor and
User modes. Thus, as long as the MMU's User mode memory has been set ahead of
time, the RTI instruction can be used to switch the context of a running
program.

To change context from supervisor to user mode, the MMU's user mode memory
should be set, and the stack should be loaded with user-mode values for the 
R0-R7, FL, USP, PS, and PC registers:

    1. Load the MMU cache with the necessary user data.
    2. Pop R0-R7 from the stack.
    3. Pop FL, USP.
    4. Use RTI to pop PS, PC from the stack (PC should have S bit cleared).
    5. Execution will continue.
            
            POP R0, R1, R2, R3, R4, R5, R6, R7
            POP FL, USP
            RTI ; pops PS and PC

To save context (when responding to an interrupt from user mode). Note that upon
entering the interrupt, the stack looks like this:

                            [ ... ]
                            [ PS  ]
                    SP -->  [ PC  ]

    1. Push FL and USP to the stack.
    2. Push R0-R7 to the stack.
    3. Save the user MMU cache to the stack.

            PSH FL, USP
            PSH R0, R1, R2, R3, R4, R5, R6, R7

--- 2.I.2. Switching Context while in Superivosr Mode --------------------------

Switching context from supervisor to supervisor is more difficult, as modifying
the active MMU cache will change the instruction that PC is operating on. It is
advised that the software either disable the MMU as part of this operation,
or lay out the banks of memory in such a way that when changing banks, the 
context changing sequence will go on interrupted (the same sequence of context
changing might be used in all banks).

    
### 3. Instructions ############################################################

The YCPU's instruction set is comprised of 67 instructions (and four 'macros',
where an opcode is known by two names: "NOP" is a second code for "LOD R0, R0").

Each instruction is represented by an 8-bit opcode within the low octet of a
16-bit program word. The program word can be followed by 1, or in rare cases,
two immediate word values.

There are 68 undefined opcodes: STO Immediate (0x00A8), STO Register (0x00AA),
0x00AD, 0x00B4, and 0x00C0 through 0x00FF inclusive. Undefined opcodes will
raise the 'undefined' interrupt on execution.

Low octet   Mnemonic    Priv?   Bit Pattern     Description               Cycles
0000 0RRR   CMP                 ALU             Compare R and M, sets FL      1
0000 1RRR   NEG                 ALU             R = 0 - R (two's complement)  1
0001 0RRR   ADD                 ALU             R = R + M                     1
0001 1RRR   SUB                 ALU             R = R - M                     1  
0010 0RRR   ADC                 ALU             R = R + M + C                 1  
0010 1RRR   SBC                 ALU             R = R - M - (1 - C)           1  
0011 0RRR   MUL                 ALU             R = R * M (16x16=32b)         8   
0011 1RRR   DIV                 ALU             R = R / M                    48 
0100 0RRR   MLI                 ALU             R = R * M (signed 16x16=32b)  8 
0100 1RRR   DVI                 ALU             R = R / M (signed)           48 
0101 0RRR   MOD                 ALU             R = R % M (modulus)          48 
0101 1RRR   MDI                 ALU             R = R % M (modulus, signed)  48 
0110 0RRR   AND                 ALU             Bitwise and                   1 
0110 1RRR   ORR                 ALU             Bitwise or                    1 
0111 0RRR   EOR                 ALU             Bitwise exclusive or          1   
0111 1RRR   NOT                 ALU             Bitwise not                   1 

1000 0RRR   LOD                 ALU             Load                          1 
1000 1RRR   STO                 ALU             Store                         1 
1001 0bbb   Bxx                 BRA             Branch operations             1
1001 1bbb   Bxx                 BRA             Branch operations             1
1010 0000   ASL                 SHF             Arithmetic Shift left         4
1010 0001   LSL                 SHF             Logical Shift Left            4
1010 0010   ROL                 SHF             Rotate Through-Carry Left     2
1010 0011   RNL                 SHF             Rotate No-Carry Left          2
1010 0100   ASR                 SHF             Arithmetic Shift Right        4
1010 0101   LSR                 SHF             Logical Shift Right           4
1010 0110   ROR                 SHF             Rotate Through-Carry Right    2
1010 0111   RNR                 SHF             Rotate No-Carry Right         2
1010 1000   BTT                 BTI             Test a bit                    2
1010 1001   BTX                 BTI             Test a bit and change it      2
1010 1010   BTC                 BTI             Test a bit and clear it       2
1010 1011   BTS                 BTI             Test a bit and set it         2    
1010 110x   ---                 ---             UNDEFINED                     -
1010 1110   SEF                 FLG             Set flag bit                  1
1010 1111   CLF                 FLG             Clear flag bit                1
1011 000x   PSH                 STK             Push to stack                 1 
1011 001x   POP                 STK             Pop from stack                1 
1011 0100   ---                 ---             UNDEFINED                     -
1011 0101   MM[R/W/L/S] X       MMU             MMU Rd/Wri/Lod/Sto            1
1011 011x   SET                 SEI             Set register to value         1
1011 1000   INC/ADI             IMM             Inc / Add immediate           1
1011 1001   DEC/SBI             IMM             Dec / Subtract immediate      1
1011 1010   JMP         /       JMI             Jump                          2 
1011 1011   JSR         /       JMI             Jump to Subroutine            3 
1011 1100   HWQ         X       HWI             Hardware Bus Query            4
1011 1101   SLP         X       ---             Sleep until Interrupt         1
1011 1110   SWI                 ---             Raise SOFTWARE Interrupt      2     
1011 1111   RTI         X       ---             Return from Interrupt         4 
11xx xxxx   ---                 ---             UNDEFINED (64 opcodes)        -


=== 3.A. Bit Patterns ==========================================================

ALU Bit Pattern
    FEDC BA98 7654 3210                             
    AAAA rrrE OOOO ORRR
        R = Destination/Source Register
        O = Opcode
        A = Addressing Mode
        r = Second Operand Register. Can be used as:
            Index Register. See Note 1, below.
            Stack Offset. See Note 2, below.
            Processor register. See Note 4, below.
        E = 8-bit Mode. See Note 3, below.
    
    AAAA rrrE OOOO ORRR     Addressing Mode     Example Syntax      Cycles  Note
    0000 000E       RRR     Immediate           LOD R0, $1234       +1m     
    0000 001E       RRR     Absolute            LOD R0, [$1234]     +2m     
    0001 ppp.       RRR     ProcReg             LOD R0, SP                  4
    0010 rrrE       RRR     Register            LOD R0, R1                  
    0011 rrrE       RRR     Indirect            LOD R0, [R1]        +1m     
    0100 rrrE       RRR     Absolute Offset     LOD R0, [$1234,R1]  +2m     
                            Indirect Offset     LOD R0, [R1,$1234]  +2m
    0101 rrrE       RRR     Stack Offset        LOD R0, S[$00]      +1m     2
    0110 rrrE       RRR     Indirect PostInc    LOD R0, [R1+]       +1m
    0111 rrrE       RRR     Indirect PreDec     LOD R0, [-R1]       +1m
    1iii rrrE       RRR     Indirect Indexed    LOD R0, [r1,i2]     +1m     1
    
        Note 1: The 'r' bits in the ALU Bit Pattern are used to determine
                the index register in the 'Indirect Indexed' addressing mode.
        Note 2: The 'r' bits describe a value between $00 and $07. This value
                is used as an offset into the stack. S[$00] returns the value
                at the stack pointer; S[$07] returns the value at [StckPtr + 7].
        Note 3: When the 'E' bit is set, the ALU processes values in its 8-bit
                mode. To use 8-bit mode for ALU instructions, follow the normal
                opcode with a ".8" flag. Examples follow:
                
                Instruction             Compiled as:
                LOD.8   R0, $34         LOD R0 = $34, 8-bit operation.
                STO.8   R0, [R1,R2]     STO R0 = [R1,R2], 8-bit operation.
                LOD.8   R0, $1234       Will raise an error during assembly, as
                                        $1234 is greater than an 8-bit value.
        Note 4: The processor can also use a processor register as an operand.
                Processor register indexes are as follows:
                Index   Desc.                                   Supervisor only?
                $00     FL register                                     N
                $01     PC register                                     N
                $02     PS register                                     Y
                $03     P2 register                                     Y
                $04     II register                                     Y
                $05     IA register                                     Y
                $06     USP                                             N
                $07     current Stack Pointer (USP / SSP)               N
                                        
    The ALU operating in 8-bit mode has the following modified behaviour:
        1.  Only the low 8-bits of the input registers are used.
        2.  Only the low 8-bits of the output register are set. The high 8-bits
            of the output register are cleared (set to '0').
        3.  The [N]egative flag bit is set if bit 7 is set (with 16-bit
            operations, the N flag is set if bit 15 is set).
        4.  Only the low 8 bits of an immediate value are loaded, and the
            following byte is skipped (the entire 16 bits of offsets and
            absolute values are still used).

BTI Bit Pattern
    FEDC BA98 7654 3210
    rrrR ssss OOOO OOOO
        O = Opcode
        r = register to test
        R = 0: test bit with value = s ($0 - $f)
            1: test bit with value = (Rx & $0F), (ssss used as .rrr)

BRA Bit Pattern
    FEDC BA98 7654 3210                        
    bbbb bbbb OOOO Occc                    
        O = opcode
        b = signed 8-bit offset (multiplied by 2)
        c = condition (See 3.E. 'Branch Operations')
     
FLG Bit Pattern
    FEDC BA98 7654 3210
    NZCV .... OOOO OOOO
        O = Opcode
        N = Negative flag bit
        Z = Zero flag bit
        C = Carry flag bit
        V = oVerflow flag bit
        
HWI Bit Pattern
    FEDC BA98 7654 3210
    iiii iiii OOOO OOOO
        O = Opcode
        i = Type of Hardware Busy Query operation
            Index   Operation
            $00     Bus Device Count. R0 = number of devices attached to bus.
            $01     Bus Device Query. R0-R3 are set with information about the
                    device at Bus index = R0
                    R0: Device Type
                    R1: Manufacturer ID
                    R2: Device ID
                    R3: Device Flags
            $02     Bus Device Message. Send a message to device at bus index =
                    R0, with parameters in R1-R2, and possibly in memory if a
                    register is a pointer. See 2.C., Infra.
            $80     Gets time data from RTC.
                    See 2.H.1. for the format of the time data. 
            $81     Set RTC interrupt based on the value of R0.
                    See 2.H.2. for the input format of R0.
            
    
    
IMM Bit Pattern
    FEDC BA98 7654 3210
    RRRv vvvv OOOO OOOO
        O = Opcode
        r = register to be incremented
        v = value to increment register by (5-bit value + 1, range of $01-$20)
    
    
JMI Bit Pattern
    FEDC BA98 7654 3210 
    AAAA rrrF OOOO OOOO
        O = Opcode
        A = Addressing mode
        r = Source register
        i = Index Register. See Note 1, below.
        s = Stack Offset. See Note 2, below.
        F = Far Mode. See Note 3, below.
        
    AAAA rrrF OOOO OOOO     Addressing Mode     Example Syntax          Cycles
    0000 000F               Immediate           JMP $1234               +1m
    0000 001F               Absolute            JMP [$1234]             +2m
    0010 rrrF               Register            JMP R              
    0011 rrrF               Indirect            JMP [R]                 +1m
    0100 rrrF               Absolute Offset     JMP [$1234,R]           +2m
                            Indirect Offset     JMP [R,$1234]           +2m
    0101 sssF               Stack Offset        JMP S[$00]              +1m
    0110 rrrF               Indirect PostInc    JMP [R+]                +1m
    0111 rrrF               Indirect PreDec     JMP [-R]                +1m
    1iii rrrF               Indirect Indexed    JMP [R,i]               +1m
    
        Note 1: The 'i' bits in the ALU Bit Pattern are used to determine
                the index register in the 'Indirect Indexed' addressing mode.
        Note 2: The 's' bits describe a value between $00 and $07. This value
                is used as an offset into the stack. S[$00] returns the value
                at the stack pointer; S[$07] returns the value at [StckPtr + 7].
        Note 3: When the 'F' bit is clear, the jump is 'short', and the PC will
                be set to the value implied by the addressing mode, within the 
                currently loaded 16-bit logical memory space.
                When the 'F' bit is set, the jump is 'far', and will not only
                change the PC, but will also change the logical memory space
                within the bank of the upper address. This process is detailed
                in 2.F.5., supra.
                Far jumps are only available in Supervisor mode.
                
                Addressing Mode     Upper Address   Lower Address...    
                Immediate           PC + 4          PC + 2
                Absolute            [(PC + 2) + 2]  [PC + 2]
                Register            R[+1]           R       // See Note 4.
                Indirect            [R + 2]         [R]
                Absolute Offset     [($1234,R) + 2] [$1234,R]
                Indirect Offset     [(R,$1234) + 2] [R,$1234]
                Stack Offset        S[s + 1]        S[s]    // +1 stk = +2 bytes
                Indirect PostInc    [R + 2]         [R]     // post-increment
                Indirect PreDec     [R - 4]         [R - 2] // pre-decrement
                Indirect Indexed    [R,i + 2]       [R,i]
                
        Note 4: Register addressing with far jumps takes the PC address from the
                specified register, and the 'upper address' from the register
                with the next index. Register indexes wrap at 8. Examples:
                JMP.F   R0      ; PC=R0 @ R1
                JMP.F   R4      ; PC=R4 @ R5
                JMP.F   R7      ; PC=R7 @ R0

                
MMU Bit Pattern
    FEDC BA98 7654 3210 
    RRRr rroo OOOO OOOO
        O = Opcode
        o = MMU operation:
            $0 = MMR
            $1 = MMW
            $2 = MML
            $3 = MMS
        r = Ra
        R = Rv


SEI Bit Pattern
    FEDC BA98 7654 3210
    RRRv vvvv OOOO OOOA
        O = Opcode
        R = destination register
        v = value
        A = alternate value select
        
        If A == 0:            R = v        Constant values from $00 - $1F
        If A == 1:
            v = $00...$0A   : R = (2^(5+v)) Power of two constants 2^5 ~ 2^15.
            v = $0B...$1F   : R = ($FFE0 + v).


SHF Bit Pattern
    FEDC BA98 7654 3210 
    rrrR ssss OOOO ODoo
        O = Opcode
        o = Sub-Opcode
            00 = ASx, 01 = LSx, 10 = ROx, 11 = RNx
        D = direction
            0 = L, 1 = R
        r = register to shift
        R = shift value select, see s
        s = if R = 0, bits to shift (1-16)
            if R = 1, register to use as shift value (register index = .sss)

            
STK Bit Pattern < 1 / 2 >
    FEDC BA98 7654 3210                        
    rrrr rrrr OOOO OOO0
        O = Opcode
        r = push/pop general purpose registers with indexes = (bit number - 8)

        
STK Bit Pattern < 2 / 2 >
    FEDC BA98 7654 3210                        
    fcp2 iaus OOOO OOO1                                     Supervisor only?
        O = Opcode
        f = push/pop FL register                                N
        c = push/pop PC register                                N
        p = push/pop PS register                                Y
        2 = push/pop P2 register                                Y
        i = push/pop II register                                Y
        a = push/pop IA register                                Y
        u = push/pop USP                                        N
        s = push/pop current Stack Pointer (USP / SSP)          N

        
=== 3.B. ALU Instructions ======================================================

Note: all ALU instructions support the .8 bitflag.

ADC         Add value to register with carry
Operation:  Rx + M + C -> Rx, C
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Set if overflow in bit 15.
    V [Overflow] Set if sign bit (bit 15) is incorrect.


ADD         Add value to register, carry is ignored.
Operation:  Rx + M -> Rx, C
For small immediate values, ($01-$20), ADD should be optimized to ADI.
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Set if overflow in bit 15.
    V [Overflow] Set if sign bit (bit 15) is incorrect.
    
    
AND         Bitwise AND register with value
Operation:  Rx & M -> M
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Not effected.
    V [Overflow] Not effected.


CMP         Compares register with value and sets appropriate flags
Operation:  Z,C,N,V = Rx - M
    N [Negative] Set if Rx >= M (signed)
    Z [Zero] Set if Rx == M.
    C [Carry] Set if Rx >= M (unsigned)
    V [Overflow] Not effected.
    
    
DIV         Unsigned Divide register by value
Operation:  Rx / M -> Rx
If a divide by zero is attempted, interrupt 0x03 is raised and Rx is unchanged.
    N [Negative] Always cleared.
    Z [Zero] Set if Rx == 0.
    C [Carry] Not effected.
    V [Overflow] Not effected.


DVI         Signed divide of register by value
Operation:  Rx / M -> Rx
If a divide by zero is attempted, interrupt 0x03 is raised and Rx is unchanged.
    N [Negative] Set if bit 15 of Rx is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Not effected.
    V [Overflow] Set if 0x8000 / 0xFFFF is attempted, Rx = 0x8000

EOR         Bitwise Exclusive OR of register with value
Operation:  Rx ^ M -> Rx
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Not effected.
    V [Overflow] Not effected.
    
    
LOD         Loads a value into a specified register
Operation:  M -> Rx
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Not effected.
    V [Overflow] Not effected.

    
MDI         Signed modulus of register by value.
Operation:  Rx % M -> Rx
Sign of the result is the same as the sign of the dividend.
If a divide by zero is attempted, interrupt 0x03 is raised and Rx is unchanged.
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Not effected.
    V [Overflow] Not effected.


MLI         Signed 16b register X 16b value with 32b result.
Operation:  Rx * M -> Rx,R0
R0 is set to the high 16-bits of the result before Rx is set with the low
16-bits of the result. If Rx and R0 are the same, R0 will equal the low
16-bits of the result, and the high 16-bits will be lost.
    N [Negative] Set if bit 15 of the high 16-bits is set.
    Z [Zero] Set if both the high 16-bits and Rx == 0.
    C [Carry] Set if high 16-bits != 0.
    V [Overflow] Not effected.


MOD         Modulus of register by value.
Operation:  Rx % M -> Rx
If a divide by zero is attempted, interrupt 0x03 is raised.
    N [Negative] Set if bit 15 of Rx is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Not effected.
    V [Overflow] Not effected.


MUL         Unsigned 16b register X 16b value with 32b result.
Operation:  Rx * M -> Rx,R0
R0 is set to the high 16-bits of the result before Rx is set with the low
16-bits of the result. If Rx and R0 are the same, R0 will equal the low
16-bits of the result, and the high 16-bits will be lost.
    N [Negative] Always cleared.
    Z [Zero] Set if the high 16-bits and Rx == 0.
    C [Carry] Set if high 16-bits != 0.
    V [Overflow] Not effected.


NEG         Changes the sign of a value, stores result in Source Reg.
Operation:  NEG(M) -> Rx
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Not effected.
    V [Overflow] Set if input value is 0x8000, Rx = 0x8000;


NOT         Bitwise NOT of value, stores result in Source Reg.
Operation:  !M -> Rx
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Not effected.
    V [Overflow] Not effected.


ORR         Bitwise OR of register with value.
Operation:  Rx | M -> Rx
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Not effected.
    V [Overflow] Not effected.
    
    
SBC         Subtract value from register, with carry.
Operation:  Rx - M - (1-C) -> Rx, C
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Set if overflow in bit 15.
    V [Overflow] Set if sign bit (bit 15) is incorrect.


STO         Stores the value of a register into another register or memory
Operation:  Rx -> M
NOTE:   Immediate and Register addressing is not available with STO opcodes.
        Thus the two opcodes that would code for STO with these addressing
        modes are UNDEFINED.
        STO Rx, Ry is an assembler macro for LOD Ry, Rx
    N [Negative] Not effected.
    Z [Zero] Not effected.
    C [Carry] Not effected.
    V [Overflow] Not effected.
    
    
SUB         Subtract value from register, ignoring carry.
Operation:  Rx - M -> Rx, C
For small immediate values, ($01-$20), SUB should be replaced with SBI.
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Set if overflow in bit 15.
    V [Overflow] Set if sign bit (bit 15) is incorrect.
    
    
=== 3.C. Bit Shifting Instructions =============================================

All bit-shifting operations must specify the number of bits to be shifted. This
number is a 4-bit number from ($00 - $0F). If the number of bits to shift is
specified as $00, then no shift takes place, but flags are still effected.


ASL         Arithmetic Shift Left
Shifts all the bits of Rx X bits to the left. The leftmost X bits are set to 0.
The carry flag is set if any bits shifted out were 1, otherwise clear. The
result is that Rx is multiplied by 2^X, treating Rx as an unsigned word, and
setting the carry flag if the result does not fit in 16 bits.
Syntax:
    ASL R0, 8       ; Arithmetic Shift Left of R0 by 8 bits.
    ASL R0, R1      ; Arithmetic Shift Left of R0 by (R1 & 0x000F) bits.
Operation:  
    N [Negative]    Set if bit 15 of the result is set.
    Z [Zero]        Set if Rx == 0.
    C [Carry]       Set if any bits shifted out were 1, otherwise clear.
                    Clear on shift zero.
    V [Overflow]    Not effected.
    
    
ASR         Arithmetic Shift Right
Shifts all the bits of Rx X bits to the right. The rightmost X bits are copied
from the old bit 15. The carry flag is set if any bits shifted out were 1,
otherwise clear. The result is that Rx is divided by 2^X, treating Rx as a
signed word, and setting the carry flag if the result does not fit in 16 bits.
For positive values, this operation will divide towards 0; for negative values,
this operation will divide towards -1.
Operation:  
    N [Negative]    Set if bit 15 is set.
    Z [Zero]        Set if Rx == 0.
    C [Carry]       Set if any bits shifted out were 1, otherwise clear.
                    Clear on shift zero.
    V [Overflow]    Set if input != $FFFF (-1), and output == $FFFF.
    
   
LSL         Logical Shift Left
This operation is equivalent to ASL.
Operation:  
    N [Negative]    Set if bit 15 of the result is set.
    Z [Zero]        Set if Rx == 0.
    C [Carry]       Set if any bits shifted out were 1, otherwise clear.
                    Clear on shift zero.
    V [Overflow]    Not effected.
    
    
LSR         Logical Shift Right
Shifts all the bits of Rx X bits to the right. The rightmost X bits are set to
zero. The carry flag is set if any bits shifted out were 1, otherwise clear. The
result is that Rx is divided by 2^X, treating Rx as an unsigned word, and
setting the carry flag if the result does not fit in 16 bits.
Operation:  
    N [Negative]    Set if bit 15 of the result is set.
    Z [Zero]        Set if Rx == 0.
    C [Carry]       Set if any bits shifted out were 1, otherwise clear.
                    Clear on shift zero.
    V [Overflow]    Not effected.
    
    
RNL         Rotate No-Carry Left
Rotate all of the bits in Rx X bits to the left, without using the carry bit.
Operation:  
    N [Negative]    Set if bit 15 is set.
    Z [Zero]        Set if Rx == 0.
    C [Carry]       Not effected.
    V [Overflow]    Not effected.
    
    
RNR         Rotate No-Carry Right
Rotate all of the bits in Rx X bits to the right, without using the carry bit.
Operation:  
    N [Negative]    Set if bit 15 is set.
    Z [Zero]        Set if Rx == 0.
    C [Carry]       Not effected.
    V [Overflow]    Not effected.
    
    
ROL         Rotate Through-Carry Left
Rotate all of the bits in Rx X bits to the left, through carry.
Operation:  
    N [Negative]    Set if bit 15 is set.
    Z [Zero]        Set if Rx == 0.
    C [Carry]       Set to the contents of the old bit (16-X).
                    Not effected on shift of zero.
    V [Overflow]    Not effected.
    
    
ROR         Rotate Through-Carry Right
Rotate all of the bits in Rx X bits to the right, through carry.
Operation:  
    N [Negative]    Set if bit 15 is set.
    Z [Zero]        Set if Rx == 0.
    C [Carry]       Set to the contents of the old bit (X-1).
                    Not effected on shift of zero.
    V [Overflow]    Not effected.
  
  
=== 3.D. Bit Testing Instructions ==============================================

BTT         Test a bit
Operation:  Rx{B} -> Z, C
    N [Negative] Not effected.
    Z [Zero] Set if Rx{B} is clear, clear otherwise.
    C [Carry] Not effected.
    V [Overflow] Not effected.


BTX         Test a bit and change it
Operation:  !Rx{B} -> Rx{B}, Z, C
    N [Negative] Not effected.
    Z [Zero] Set if old Rx{B} was clear, clear otherwise.
    C [Carry] Set if new Rx{B} is set.
    V [Overflow] Not effected.

    
BTC         Test a bit and clear it
Operation:  Rx{B} -> Rx{B}, Z, C
    N [Negative] Not effected.
    Z [Zero] Set if old Rx{B} was clear, clear otherwise.
    C [Carry] Set if old Rx{B} != new Rx{B}.
    V [Overflow] Not effected.

    
BTS         Test a bit and set it
Operation:  !Rx{B} -> Rx{B}, Z, C
    N [Negative] Not effected.
    Z [Zero] Set if old Rx{B} was clear, clear otherwise.
    C [Carry] Set if old Rx{B} != new Rx{B}.
    V [Overflow] Not effected.
    
  
=== 3.E. Branch Operations =====================================================

Branch instructions allow software to change the PC relative to its current
value. Each branch instruction includes a signed byte value (the offset) in its
bit pattern:

    BRA Bit Pattern
    FEDC BA98 7654 3210                        
    bbbb bbbb OOOO Occc                    
        O = opcode
        b = signed 8-bit offset (-128 to +127)
        c = condition
        
When a branch opcode is executed and its condition is true, the signed offset is
added to the PC. Note that because instructions must be 16-bit aligned, the offset
is shifted left by 1 (multiplied by 2) to allow for an effective range of -128 to
+127 opcodes relative to the current PC.

1001 0ccc   BXX                                                             NZCV
      000 = BCC/BUF, Branch if carry clear AKA Unsigned Fewer Than          ..0.
      001 = BCS/BUH, Branch if carry set AKA Unsigned Higher Than or Same   ..1.
      010 = BNE, Branch if zero clear                                       .0..
      011 = BEQ, Branch if zero set                                         .1..
      100 = BPL/BSF, Branch if negative clear AKA Signed Fewer Than         0...
      101 = BMI/BSH, Branch if negative set AKA Signed Higher Than Or Same  1...
      110 = BVC, Branch if overflow clear                                   ...0
      111 = BVS, Branch if overflow set                                     ...1
1001 1ccc   BXX 
      000 = BUG, Branch if Unsigned Greater than                            .11.
      001 = BSG, Branch if Signed Greater than                              11..
      010 = Undefined                                                       ....
      011 = Undefined                                                       ....
      100 = Undefined                                                       ....
      101 = Undefined                                                       ....
      110 = Undefined                                                       ....
      111 = BAW, Branch always                                              ....


=== 3.F. Immediate Instructions ================================================
    
ADI         Add immediate value to register, carry is ignored.
Operation:  Rx + M -> Rx, C
M is a 5-bit value + 1, for a range of ($01-$20).
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Set if overflow in bit 15.
    V [Overflow] Set if sign bit (bit 15) is incorrect.


DEC         Decrement register by 1.
Operation:  Rx + M -> Rx, C
This operation is an assembler macro for SBI Rx, $01
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Set if overflow in bit 15.
    V [Overflow] Set if sign bit (bit 15) is incorrect.
    
    
INC         Increment register by 1.
Operation:  Rx + M -> Rx, C
This operation is an assembler macro for ADI Rx, $01
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Set if overflow in bit 15.
    V [Overflow] Set if sign bit (bit 15) is incorrect.
    
    
SBI         Subtract immediate value from register, carry is ignored.
Operation:  Rx + M -> Rx, C
M is a 5-bit value + 1, for a range of ($01-$20).
    N [Negative] Set if bit 15 is set.
    Z [Zero] Set if Rx == 0.
    C [Carry] Set if overflow in bit 15.
    V [Overflow] Set if sign bit (bit 15) is incorrect.
    
    
=== 3.G. Interrupt Instructions ================================================

RTI         Return from Interrupt
Returns from an interrupt.
See 2.D.5. for a description of this opcode's function.
  
  
SWI         Call Software Interrupt
Raises SOFTWARE INTERRUPT.
See 2.D.4. for a description of this opcode's function.
    
    
=== 3.H. Jump & Call Instructions ==============================================

JMP         Unconditional Jump to new address.
    1. PC is set to the value of M.
    2. Execution continues.


JSR         Unconditional Jump, saving return address.
    1. PC is pushed to the stack. [PC is the address of the NEXT operation]
    2. PC is set to the value of M.
    3. Execution continues.


RTS         Return from Subroutine
NOTE: Assembler macro for 'POP PC'; no opcode is assigned to this instruction.
    1. M is popped from the stack. PC is set to M.
    2. Execution continues.
    
    
=== 3.I. Stack Instructions ====================================================
The following registers can be specified for Stack Instructions:
R0-R7, A-C, I-J, X-Z, FL, PC, PS, SP, USP, P2, II, and IA. Specifying a register
twice (ex. R0 and A) will result in only one value popped to or pushed from
that register.

There are two separate operations for pop and two for pull, each addressing a
different set of registers. The first operation pops or pulls the eight general
purpose registers, R0-R7. The second operation pops or pulls processor status
registers SP, Fl, PC, PS, USP, P2, II, and IA. 

Two notes on pushing and pulling the stack pointers. First, 'SP' and 'USP' is
the value of these stack pointers BEFORE the operation. Thus if SP is $1000 and
the operation 'PSH SP' is called, SP will now be $0FFF and the first value on
the stack will be $1000. Second, 'SP' equates to the current stack pointer, and
thus could be either USP or SSP depending on the mode of the processor.
Executing 'PSH USP, SP' in user mode will push USP to the stack twice; the same
instruction in supervisor mode will push both USP and SSP to the stack.

Note that pushing and pulling 'PS', the processor status register, is a
privileged operation. Attempting to push or pull this register in user mode
will result in all other specified registers being pushed or pulled, followed by
an 'Unprivileged opcode' interrupt.

An assembler should transform a stack operation that includes registers from 
these two different register groups should split the operation into two
separate operations as follows: general purpose registers should always be
popped first, and pushed last. Thus these two example instructions:
    PSH R0, R1, SP, PC
    POP R0, R1, SP, PC              
Should be transformed into:
    PSH SP, PC
    PSH R0, R1
    POP R0, R1                      
    POP SP, PC              
    
    
POP         Pop values from the Stack into registers
Syntax: Pop Rx[,Rx,Rx...]
The processor sequentially loads values from the stack to the registers
specified. Regardless of the order of the registers specified in the
instruction, the registers are always popped in the following order:
    Bit pattern 0: R7, R6, R5, R4, R3, R2, R1, R0
    Bit pattern 1: FL, PC, PS, P2, II, IA, USP, SP
    
    
PSH         Push values from registers to the Stack
Syntax: Pop Rx[,Rx,Rx...]
The processor sequentially saves a number of values from the stack equal to
the number of registers specified.
Regardless of the order of the registers specified in the instruction, the
values registers are always pushed in the following order:
    Bit pattern 0: R0, R1, R2, R3, R4, R5, R6, R7
    Bit pattern 1: SP, USP, IA, II, P2, PS, PC, FL
    

=== 3.J. Processor Function Instructions =======================================

CLF         Clears bit(s) in the FL register.
Syntax: CLF [N][,C][,Z][,V]
The specified bits are cleared in the FL register. Any combination of the
possible bits may be specified in a single instruction.


HWQ         Sends a message to the Hardware Bus.
Syntax: HWQ $00
Sends a message with the specified identified to the Hardware Bus. This may
query the bus directly, or send a message to a hardware device.


MML         Pushes 4 words of MMU cache data onto the stack.
Syntax: MML Rv
Reads the 4 word MMU cache and pushes it onto the stack. The lowest bit of Rv
determines whether the user or supervisor MMU cache is loaded in this way; if
the bit is clear, the user cache is loaded; if the bit is set, the supervisor
is loaded.


MMR         Reads a word from the Memory Management Cache into a register.
Syntax: MMR Ra, Rv
Retrieves a value from Memory Management Cache at index Ra and loads it into
register Rv. The value in Ra is interpreted as follows:
        $0000 - first word of user cache
        ...
        $0007 - last word of user cache
        $0008 - first word of supervisor cache
        ...
        $000F - last word of supervisor cache  


MMS         Pulls 4 words from stack and write these to the MMU cache.
Syntax: MMS Rv
Pulls 4 words from the stack and writes these to the MMU cache. As with MML, the
lowest bit of Rv determines whether the user or supervisor MMU cache is loaded
in this way; if the bit is clear, the user cache is loaded; if the bit is set,
the supervisor is loaded. Note that if the M processor status bit is set when
this operation runs, the instructions the processor is operating on will almost
certainly be changed.


MMW         Writes a word to the Memory Management Cache from a register.
Syntax: MMR Ra, Rv
Loads a value from Rv into the Memory Management Cache at index Ra. See MMR for
how value of Ra is interpreted.


NOP         No effect, cycle count increases by 1.
Syntax: NOP
Nothing happens. This is a macro for LOD R0, R0


SEF         Sets bit(s) in the FL register.
Syntax: SEF [N][,C][,Z][,V]
The specified bits are set in the FL register. Any combination of the
possible bits may be specified in a single instruction.


SLP         Halts the processor until it receives an interrupt.
Syntax: SLP
Places the processor into a halted state. No further instructions will be
executed until a hardware interrupt is received, at which point the processor
will exit the halted state and continue execution after the interrupt is
handled.


### 4. History #################################################################
Please refer to the file 'ycpu history.txt' for a complete history of revisions
to the YCPU specification.
